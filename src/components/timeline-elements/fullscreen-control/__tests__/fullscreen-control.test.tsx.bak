import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
import { ThemeProvider } from 'styled-components';
import { FullscreenControl } from '../index';
import { Theme } from '@models/Theme';
import React, { useRef } from 'react';

// Mock theme for testing
const mockTheme: Theme = {
  primary: '#007bff',
  secondary: '#6c757d',
  cardBgColor: '#ffffff',
  toolbarBtnBgColor: '#f8f9fa',
  buttonBorderColor: '#dee2e6',
  shadowColor: 'rgba(0, 0, 0, 0.1)',
  iconColor: '#6c757d',
  titleColor: '#212529',
  titleColorActive: '#007bff',
  cardTitleColor: '#212529',
  textColor: '#6c757d',
  buttonHoverBgColor: '#e9ecef',
  buttonActiveBgColor: '#007bff',
  buttonActiveIconColor: '#ffffff',
  glowColor: 'rgba(0, 123, 255, 0.25)',
};

// Test wrapper component that properly initializes refs
const TestWrapper = ({ 
  children, 
  onEnterFullscreen, 
  onExitFullscreen, 
  onError,
  ...props 
}: any) => {
  const [targetRef, setTargetRef] = React.useState<React.RefObject<HTMLDivElement>>({ current: null });
  
  React.useEffect(() => {
    const element = document.createElement('div');
    // Setup fullscreen API on the element
    Object.defineProperty(element, 'requestFullscreen', {
      writable: true,
      configurable: true,
      value: mockFullscreenAPI.requestFullscreen,
    });
    setTargetRef({ current: element });
  }, []);
  
  return (
    <ThemeProvider theme={mockTheme}>
      <div>
        <div ref={targetRef} data-testid="target-element">
          Target Element
        </div>
        {targetRef.current && (
          <FullscreenControl
            targetRef={targetRef}
            theme={mockTheme}
            onEnterFullscreen={onEnterFullscreen}
            onExitFullscreen={onExitFullscreen}
            onError={onError}
            {...props}
          />
        )}
        {children}
      </div>
    </ThemeProvider>
  );
};

describe('FullscreenControl', () => {
  let mockTargetRef: React.RefObject<HTMLDivElement>;
  let mockOnEnter: jest.Mock;
  let mockOnExit: jest.Mock;
  let mockOnError: jest.Mock;

  // Mock fullscreen API
  const mockFullscreenAPI = {
    requestFullscreen: vi.fn().mockResolvedValue(undefined),
    exitFullscreen: vi.fn().mockResolvedValue(undefined),
    fullscreenElement: null,
    fullscreenEnabled: true,
  };

  beforeEach(() => {
    vi.clearAllMocks();
    mockOnEnter = vi.fn();
    mockOnExit = vi.fn();
    mockOnError = vi.fn();

    // Mock the target ref
    const targetElement = document.createElement('div');
    mockTargetRef = { current: targetElement };

    // Mock fullscreen API on document
    Object.defineProperty(document, 'fullscreenEnabled', {
      writable: true,
      configurable: true,
      value: true,
    });
    Object.defineProperty(document, 'fullscreenElement', {
      writable: true,
      configurable: true,
      value: null,
    });
    Object.defineProperty(document, 'exitFullscreen', {
      writable: true,
      configurable: true,
      value: mockFullscreenAPI.exitFullscreen,
    });
    
    // Mock fullscreen API on element
    if (targetElement) {
      Object.defineProperty(targetElement, 'requestFullscreen', {
        writable: true,
        configurable: true,
        value: mockFullscreenAPI.requestFullscreen,
      });
    }
  });

  afterEach(() => {
    vi.restoreAllMocks();
  });

  describe('Rendering and Basic Functionality', () => {
    it('should render fullscreen button when supported', async () => {
      render(
        <TestWrapper
          onEnterFullscreen={mockOnEnter}
          onExitFullscreen={mockOnExit}
          onError={mockOnError}
        />
      );

      await waitFor(() => {
        const button = screen.getByTestId('fullscreen-control');
        expect(button).toBeInTheDocument();
      });
    });

    it('should not render when fullscreen is not supported', () => {
      // Mock unsupported fullscreen
      Object.defineProperty(document, 'fullscreenEnabled', {
        writable: true,
        value: false,
      });

      const TestComponent = () => {
        const targetRef = useRef<HTMLDivElement>(null);
        return (
          <TestWrapper
            targetRef={targetRef}
            onEnterFullscreen={mockOnEnter}
            onExitFullscreen={mockOnExit}
            onError={mockOnError}
          />
        );
      };

      render(<TestComponent />);

      const button = screen.queryByTestId('fullscreen-control');
      expect(button).not.toBeInTheDocument();
    });

    it('should show enter fullscreen state initially', () => {
      const TestComponent = () => {
        const targetRef = useRef<HTMLDivElement>(null);
        return (
          <TestWrapper
            targetRef={targetRef}
            onEnterFullscreen={mockOnEnter}
            onExitFullscreen={mockOnExit}
          />
        );
      };

      render(<TestComponent />);

      const button = screen.getByLabelText('Enter fullscreen');
      expect(button).toBeInTheDocument();
    });
  });

  describe('Fullscreen State Management', () => {
    it('should handle entering fullscreen', async () => {
      const TestComponent = () => {
        const targetRef = useRef<HTMLDivElement>(null);
        return (
          <TestWrapper
            targetRef={targetRef}
            onEnterFullscreen={mockOnEnter}
            onExitFullscreen={mockOnExit}
            onError={mockOnError}
          />
        );
      };

      render(<TestComponent />);

      const button = screen.getByTestId('fullscreen-control');
      fireEvent.click(button);

      await waitFor(() => {
        expect(mockFullscreenAPI.requestFullscreen).toHaveBeenCalled();
      });
    });

    it('should handle exiting fullscreen', async () => {
      // Mock being in fullscreen mode
      Object.defineProperty(document, 'fullscreenElement', {
        writable: true,
        value: mockTargetRef.current,
      });

      const TestComponent = () => {
        const targetRef = useRef<HTMLDivElement>(null);
        return (
          <TestWrapper
            targetRef={targetRef}
            onEnterFullscreen={mockOnEnter}
            onExitFullscreen={mockOnExit}
            onError={mockOnError}
          />
        );
      };

      render(<TestComponent />);

      const button = screen.getByTestId('fullscreen-control');
      fireEvent.click(button);

      await waitFor(() => {
        expect(mockFullscreenAPI.exitFullscreen).toHaveBeenCalled();
      });
    });

    it('should call onEnterFullscreen callback', async () => {
      const TestComponent = () => {
        const targetRef = useRef<HTMLDivElement>(null);
        return (
          <TestWrapper
            targetRef={targetRef}
            onEnterFullscreen={mockOnEnter}
            onExitFullscreen={mockOnExit}
          />
        );
      };

      render(<TestComponent />);

      const button = screen.getByTestId('fullscreen-control');
      fireEvent.click(button);

      await waitFor(() => {
        expect(mockOnEnter).toHaveBeenCalled();
      });
    });

    it('should call onExitFullscreen callback', async () => {
      // Mock being in fullscreen mode
      Object.defineProperty(document, 'fullscreenElement', {
        writable: true,
        value: document.createElement('div'),
      });

      const TestComponent = () => {
        const targetRef = useRef<HTMLDivElement>(null);
        return (
          <TestWrapper
            targetRef={targetRef}
            onEnterFullscreen={mockOnEnter}
            onExitFullscreen={mockOnExit}
          />
        );
      };

      render(<TestComponent />);

      const button = screen.getByTestId('fullscreen-control');
      fireEvent.click(button);

      await waitFor(() => {
        expect(mockOnExit).toHaveBeenCalled();
      });
    });
  });

  describe('Error Handling', () => {
    it('should handle fullscreen request errors', async () => {
      const mockError = new Error('Fullscreen request failed');
      mockFullscreenAPI.requestFullscreen.mockRejectedValue(mockError);

      const TestComponent = () => {
        const targetRef = useRef<HTMLDivElement>(null);
        return (
          <TestWrapper
            targetRef={targetRef}
            onEnterFullscreen={mockOnEnter}
            onExitFullscreen={mockOnExit}
            onError={mockOnError}
          />
        );
      };

      render(<TestComponent />);

      const button = screen.getByTestId('fullscreen-control');
      fireEvent.click(button);

      await waitFor(() => {
        expect(mockOnError).toHaveBeenCalledWith('Fullscreen request failed');
      });
    });

    it('should handle fullscreen exit errors', async () => {
      const mockError = new Error('Exit fullscreen failed');
      mockFullscreenAPI.exitFullscreen.mockRejectedValue(mockError);

      // Mock being in fullscreen mode
      Object.defineProperty(document, 'fullscreenElement', {
        writable: true,
        value: document.createElement('div'),
      });

      const TestComponent = () => {
        const targetRef = useRef<HTMLDivElement>(null);
        return (
          <TestWrapper
            targetRef={targetRef}
            onEnterFullscreen={mockOnEnter}
            onExitFullscreen={mockOnExit}
            onError={mockOnError}
          />
        );
      };

      render(<TestComponent />);

      const button = screen.getByTestId('fullscreen-control');
      fireEvent.click(button);

      await waitFor(() => {
        expect(mockOnError).toHaveBeenCalledWith('Exit fullscreen failed');
      });
    });

    it('should disable button when error occurs', async () => {
      const mockError = new Error('Permission denied');
      mockFullscreenAPI.requestFullscreen.mockRejectedValue(mockError);

      const TestComponent = () => {
        const targetRef = useRef<HTMLDivElement>(null);
        return (
          <TestWrapper
            targetRef={targetRef}
            onEnterFullscreen={mockOnEnter}
            onExitFullscreen={mockOnExit}
            onError={mockOnError}
          />
        );
      };

      render(<TestComponent />);

      const button = screen.getByTestId('fullscreen-control');
      fireEvent.click(button);

      await waitFor(() => {
        expect(button).toBeDisabled();
      });
    });

    it('should show error message in title when error occurs', async () => {
      const mockError = new Error('Security error');
      mockFullscreenAPI.requestFullscreen.mockRejectedValue(mockError);

      const TestComponent = () => {
        const targetRef = useRef<HTMLDivElement>(null);
        return (
          <TestWrapper
            targetRef={targetRef}
            onEnterFullscreen={mockOnEnter}
            onExitFullscreen={mockOnExit}
            onError={mockOnError}
          />
        );
      };

      render(<TestComponent />);

      const button = screen.getByTestId('fullscreen-control');
      fireEvent.click(button);

      await waitFor(() => {
        expect(button).toHaveAttribute('title', 'Fullscreen unavailable: Security error');
      });
    });
  });

  describe('Props and Customization', () => {
    it('should accept custom size prop', () => {
      const TestComponent = () => {
        const targetRef = useRef<HTMLDivElement>(null);
        return (
          <TestWrapper
            targetRef={targetRef}
            size="large"
            onEnterFullscreen={mockOnEnter}
            onExitFullscreen={mockOnExit}
          />
        );
      };

      render(<TestComponent />);

      const button = screen.getByTestId('fullscreen-control');
      expect(button).toBeInTheDocument();
    });

    it('should accept custom className', () => {
      const customClassName = 'custom-fullscreen-control';

      const TestComponent = () => {
        const targetRef = useRef<HTMLDivElement>(null);
        return (
          <TestWrapper
            targetRef={targetRef}
            className={customClassName}
            onEnterFullscreen={mockOnEnter}
            onExitFullscreen={mockOnExit}
          />
        );
      };

      render(<TestComponent />);

      const button = screen.getByTestId('fullscreen-control');
      expect(button).toHaveClass(customClassName);
    });

    it('should accept custom aria-label', () => {
      const customAriaLabel = 'Toggle fullscreen mode';

      const TestComponent = () => {
        const targetRef = useRef<HTMLDivElement>(null);
        return (
          <TestWrapper
            targetRef={targetRef}
            ariaLabel={customAriaLabel}
            onEnterFullscreen={mockOnEnter}
            onExitFullscreen={mockOnExit}
          />
        );
      };

      render(<TestComponent />);

      const button = screen.getByLabelText(customAriaLabel);
      expect(button).toBeInTheDocument();
    });

    it('should accept custom title', () => {
      const customTitle = 'Custom fullscreen title';

      const TestComponent = () => {
        const targetRef = useRef<HTMLDivElement>(null);
        return (
          <TestWrapper
            targetRef={targetRef}
            title={customTitle}
            onEnterFullscreen={mockOnEnter}
            onExitFullscreen={mockOnExit}
          />
        );
      };

      render(<TestComponent />);

      const button = screen.getByTestId('fullscreen-control');
      expect(button).toHaveAttribute('title', customTitle);
    });

    it('should be disabled when disabled prop is true', () => {
      const TestComponent = () => {
        const targetRef = useRef<HTMLDivElement>(null);
        return (
          <TestWrapper
            targetRef={targetRef}
            disabled={true}
            onEnterFullscreen={mockOnEnter}
            onExitFullscreen={mockOnExit}
          />
        );
      };

      render(<TestComponent />);

      const button = screen.getByTestId('fullscreen-control');
      expect(button).toBeDisabled();
    });

    it('should accept custom testId', () => {
      const customTestId = 'my-fullscreen-control';

      const TestComponent = () => {
        const targetRef = useRef<HTMLDivElement>(null);
        return (
          <TestWrapper
            targetRef={targetRef}
            testId={customTestId}
            onEnterFullscreen={mockOnEnter}
            onExitFullscreen={mockOnExit}
          />
        );
      };

      render(<TestComponent />);

      const button = screen.getByTestId(customTestId);
      expect(button).toBeInTheDocument();
    });
  });

  describe('Edge Cases', () => {
    it('should handle null targetRef', () => {
      const TestComponent = () => {
        const targetRef = useRef<HTMLDivElement>(null);
        targetRef.current = null;

        return (
          <TestWrapper
            targetRef={targetRef}
            onEnterFullscreen={mockOnEnter}
            onExitFullscreen={mockOnExit}
            onError={mockOnError}
          />
        );
      };

      render(<TestComponent />);

      const button = screen.getByTestId('fullscreen-control');
      fireEvent.click(button);

      // Should handle gracefully and not crash
      expect(button).toBeInTheDocument();
    });

    it('should handle missing fullscreen API methods', () => {
      // Remove fullscreen methods
      delete (mockTargetRef.current as any).requestFullscreen;
      delete (document as any).exitFullscreen;

      const TestComponent = () => {
        const targetRef = useRef<HTMLDivElement>(null);
        return (
          <TestWrapper
            targetRef={targetRef}
            onEnterFullscreen={mockOnEnter}
            onExitFullscreen={mockOnExit}
            onError={mockOnError}
          />
        );
      };

      render(<TestComponent />);

      // Should not render if APIs are missing
      const button = screen.queryByTestId('fullscreen-control');
      expect(button).not.toBeInTheDocument();
    });

    it('should handle rapid consecutive clicks', async () => {
      const TestComponent = () => {
        const targetRef = useRef<HTMLDivElement>(null);
        return (
          <TestWrapper
            targetRef={targetRef}
            onEnterFullscreen={mockOnEnter}
            onExitFullscreen={mockOnExit}
            onError={mockOnError}
          />
        );
      };

      render(<TestComponent />);

      const button = screen.getByTestId('fullscreen-control');
      
      // Click multiple times rapidly
      fireEvent.click(button);
      fireEvent.click(button);
      fireEvent.click(button);

      // Should handle gracefully without throwing errors
      expect(button).toBeInTheDocument();
    });

    it('should handle component unmounting during fullscreen operation', async () => {
      const TestComponent = () => {
        const targetRef = useRef<HTMLDivElement>(null);
        return (
          <TestWrapper
            targetRef={targetRef}
            onEnterFullscreen={mockOnEnter}
            onExitFullscreen={mockOnExit}
            onError={mockOnError}
          />
        );
      };

      const { unmount } = render(<TestComponent />);

      const button = screen.getByTestId('fullscreen-control');
      fireEvent.click(button);

      // Unmount immediately after clicking
      unmount();

      // Should not throw errors during cleanup
      expect(true).toBe(true);
    });
  });

  describe('Browser Compatibility', () => {
    it('should handle webkit fullscreen API', () => {
      // Mock webkit API
      Object.defineProperty(document, 'webkitFullscreenEnabled', {
        writable: true,
        value: true,
      });
      Object.defineProperty(document, 'webkitExitFullscreen', {
        writable: true,
        value: vi.fn().mockResolvedValue(undefined),
      });
      Object.defineProperty(mockTargetRef.current, 'webkitRequestFullscreen', {
        writable: true,
        value: vi.fn().mockResolvedValue(undefined),
      });

      const TestComponent = () => {
        const targetRef = useRef<HTMLDivElement>(null);
        return (
          <TestWrapper
            targetRef={targetRef}
            onEnterFullscreen={mockOnEnter}
            onExitFullscreen={mockOnExit}
          />
        );
      };

      render(<TestComponent />);

      const button = screen.getByTestId('fullscreen-control');
      expect(button).toBeInTheDocument();
    });

    it('should handle moz fullscreen API', () => {
      // Mock moz API
      Object.defineProperty(document, 'mozFullScreenEnabled', {
        writable: true,
        value: true,
      });
      Object.defineProperty(document, 'mozCancelFullScreen', {
        writable: true,
        value: vi.fn().mockResolvedValue(undefined),
      });
      Object.defineProperty(mockTargetRef.current, 'mozRequestFullScreen', {
        writable: true,
        value: vi.fn().mockResolvedValue(undefined),
      });

      const TestComponent = () => {
        const targetRef = useRef<HTMLDivElement>(null);
        return (
          <TestWrapper
            targetRef={targetRef}
            onEnterFullscreen={mockOnEnter}
            onExitFullscreen={mockOnExit}
          />
        );
      };

      render(<TestComponent />);

      const button = screen.getByTestId('fullscreen-control');
      expect(button).toBeInTheDocument();
    });

    it('should handle ms fullscreen API', () => {
      // Mock ms API
      Object.defineProperty(document, 'msFullscreenEnabled', {
        writable: true,
        value: true,
      });
      Object.defineProperty(document, 'msExitFullscreen', {
        writable: true,
        value: vi.fn().mockResolvedValue(undefined),
      });
      Object.defineProperty(mockTargetRef.current, 'msRequestFullscreen', {
        writable: true,
        value: vi.fn().mockResolvedValue(undefined),
      });

      const TestComponent = () => {
        const targetRef = useRef<HTMLDivElement>(null);
        return (
          <TestWrapper
            targetRef={targetRef}
            onEnterFullscreen={mockOnEnter}
            onExitFullscreen={mockOnExit}
          />
        );
      };

      render(<TestComponent />);

      const button = screen.getByTestId('fullscreen-control');
      expect(button).toBeInTheDocument();
    });
  });
});